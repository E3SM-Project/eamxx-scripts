#!/usr/bin/env python

"""
Plot results from perf_analysis
"""

from utils import expect, check_minimum_python_version
check_minimum_python_version(2, 7)

import matplotlib.pyplot as plt

from collections import OrderedDict
import argparse, sys, os, math

###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <DATAFILE> [<DATAFILE>]
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Plot data file \033[0m
    > {0} data
""".format(os.path.basename(args[0])),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("datafiles", nargs="+", help="Data file to plot")

    parser.add_argument("-d", "--dashed", action="append", help="Specify these tested should have dashed lines")

    args = parser.parse_args(args[1:])

    return args.datafiles, args.dashed

###############################################################################
def pad_lim(lim, pad=0.05, mult=False):
###############################################################################
    if mult:
        lims = lim[0] * (1 - pad), lim[1] * (1 + pad)
    else:
        d = lim[1] - lim[0]
        delta = pad * d
        lims = lim[0] - delta, lim[1] + delta
    return lims

###############################################################################
def axis_tight_pad(pad=0.05, mult=False):
###############################################################################
    plt.axis('tight')
    xl = plt.xlim()
    yl = plt.ylim()
    plt.xlim(pad_lim(xl, pad, mult))
    return plt.ylim(pad_lim(yl, pad, mult))

###############################################################################
def subtle_grid():
###############################################################################
    plt.grid(True, lw=0.5, ls='-', color=(0.8, 0.8, 0.8), zorder=-1, which='both')
    return plt.gca().set_axisbelow(True)

###############################################################################
def get_line_format(testname, color, dashed):
###############################################################################
    if dashed and testname in dashed:
        return "{}--".format(color)
    else:
        return "{}-".format(color)

###############################################################################
class Plotter(object):
###############################################################################

    def __init__(self, datafiles):
        self._scaling_var       = None
        self._scaling_factor    = None
        self._consistent        = OrderedDict()
        self._inconsistent      = []
        self._title             = None
        self._avail_colors      = ["b", "g", "r", "c", "m", "y", "k"]
        self._var_longname_map  = {"ni" : "Number of columns", "nk" : "Column levels", "dt" : "Time step", "ts" : "Number of time steps",
                                   "threads" : "Threads"}
        self._test_longname_map = {"pack" : "C++/Kokkos"}
        self._mach_longname_map = {"bowman" : "KNL", "blake" : "Skylake", "waterman" : "Nvidia_V100"}

        for datafile in datafiles:
            with open(datafile, "r") as fd:
                lines = [line.strip() for line in fd.readlines()]

            prov_line    = lines[0]
            test_line    = lines[1]
            result_line1 = lines[2]
            result_line2 = lines[3]

            scaling_var = test_line.split()[1]
            scaling_factor = float(result_line2.split(", ")[0]) / float(result_line1.split(", ")[0])
            first_file = self._scaling_var is None
            if first_file:
                self._scaling_var    = scaling_var
                self._scaling_factor = scaling_factor
            else:
                expect(self._scaling_var == scaling_var, "Incompatible files, scaling vars don't match")
                expect(self._scaling_factor == scaling_factor, "Incompatible files, scaling factors don't match")

            for item in prov_line.split()[1:]:
                key, value = item.split("=")
                if first_file:
                    self._consistent[key] = value
                else:
                    if key in self._inconsistent:
                        pass
                    elif self._consistent[key] != value:
                        del self._consistent[key]
                        self._inconsistent.append(key)

        title = []
        for key, value in self._consistent.iteritems():
            if key != "commit":
                title.append("{}={}".format(self.get_var_longname(key), value))

        self._title = ", ".join(title)

    def get_var_longname(self, var):
        return self._var_longname_map[var] if var in self._var_longname_map else var

    def get_test_longname(self, test):
        return self._test_longname_map[test] if test in self._test_longname_map else test.capitalize()

    def get_mach_longname(self, machine):
        return self._mach_longname_map[machine] if machine in self._mach_longname_map else machine.capitalize()

    def plot_line(self, xs, ys, line_label, testname, dashed, color):
        plt.plot(xs, ys, get_line_format(testname, color, dashed), lw=2,
                 label="{} {}".format(self.get_test_longname(testname), line_label))

    def plotdata(self, datafile, dashed):
        xs, ys = [], []
        testname = None
        line_label = ""
        xlabel = None
        color = self._avail_colors.pop(0)
        with open(datafile, "r") as fd:
            for line in fd.readlines():
                line = line.strip()
                if "Provenance" in line:
                    prov_dict = dict([item.split("=") for item in line.split()[1:] if not item.endswith("=None")])
                    if "machine" in self._inconsistent:
                        line_label = "on {}".format(self.get_mach_longname(prov_dict["machine"]))
                        del prov_dict["machine"]

                    if prov_dict:
                        first = True
                        for key, value in prov_dict.iteritems():
                            if key in self._inconsistent:
                                if first:
                                    line_label += " with"
                                    first = False

                                line_label += " {} {}".format(value, self.get_var_longname(key).lower())

                elif "," in line:
                    x, y = [float(item) for item in line.split(", ")]
                    xs.append(math.log(x, self._scaling_factor))
                    ys.append(y / 1000.0)

                elif line != "":
                    if xs:
                        self.plot_line(xs, ys, line_label, testname, dashed, color)
                        xs = []
                        ys = []

                    testname, xlabel = line.split()
                    expect(xlabel == self._scaling_var, "Bad file {}".format(datafile))

        self.plot_line(xs, ys, line_label, testname, dashed, color)

    def finalize(self):

        subtle_grid()
        plt.title(self._title)
        log_base_str = str(int(self._scaling_factor)) if self._scaling_factor.is_integer() else "{:.2f}".format(self._scaling_factor)
        plt.xlabel(r"$\log_{}$ {}".format(log_base_str, self.get_var_longname(self._scaling_var)), fontsize="large")
        plt.ylabel("Columns per second / $10^3$", fontsize="large")
        plt.legend(loc="best", framealpha=0)
        axis_tight_pad()

        plt.show()

###############################################################################
def _main_func(description):
###############################################################################
    datafiles, dashed = parse_command_line(sys.argv, description)

    plotter = Plotter(datafiles)

    for datafile in datafiles:
        plotter.plotdata(datafile, dashed)

    plotter.finalize()

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
