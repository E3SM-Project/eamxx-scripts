#!/usr/bin/env python

"""
Run different versions of p3 micro app and compare performance. It is
expected that this will be run from micro-apps directory.
"""

from utils import run_cmd_no_fail, run_cmd, expect, check_minimum_python_version, median
check_minimum_python_version(2, 7)

import argparse, sys, os, tempfile, re, socket

###############################################################################
class ScalingExp(object):
###############################################################################

    def __init__(self, arg_str):
        try:
            self.varname, self.scale_factor, self.upper_limit = arg_str.split(":")
            self.scale_factor = float(self.scale_factor)
            self.upper_limit  = int(self.upper_limit)
        except Exception:
            expect(False, "Scaling experiment needs to be in format VARNAME:SCALE_FACTOR:MAX")

        expect(self.varname in ["ni", "nk", "dt", "ts", "threads"], "Unknown varname '{}'".format(self.varname))

    def should_continue(self, ni, nk, dt, ts, threads):
        return locals()[self.varname] <= self.upper_limit

    def update_values(self, ni, nk, dt, ts, threads):
        """
        >>> se = ScalingExp('ni:2:1000')
        >>> se.update_values(10, 3, 300, 7, 4)
        (20, 3, 300, 7, 4)
        """
        d = {'ni':ni, 'nk':nk, 'dt':dt, 'ts':ts, 'threads':threads}
        d[self.varname] = int(d[self.varname] * self.scale_factor)
        return d['ni'], d['nk'], d['dt'], d['ts'], d['threads']

    def plot(self, results, ni, nk, dt, ts, force_threads):
        prov_msg = "Provenance: "
        for data, name in [(ni, "ni"), (nk, "nk"), (dt, "dt"), (ts, "ts"), (force_threads, "threads")]:
            if name != self.varname:
                prov_msg += " {}={}".format(name, data)

        st, out, err = run_cmd("git rev-parse --short HEAD")
        git_commit = out if st == 0 else "Unknown"
        print "{} machine={} commit={}".format(prov_msg, socket.gethostname().split(".")[0], git_commit)

        for test_name, test_results in results.iteritems():
            print test_name, self.varname
            for test_result in test_results:
                ni, nk, dt, ts, threads, med_time = test_result
                cols_sec = float(ni) / med_time
                print "{}, {:.2f}".format(locals()[self.varname], cols_sec)

###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <NI> <NK> <DT> <TS> <KOKKOS_DIR> [<CXX_COMPILER>] [-n num_runs] [--verbose]
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Run with 1 horizontal and 111 vertical columns over 300s with 30s timesteps \033[0m
    > {0} 1 111 300 30 /home/jgfouca/kokkos-install/install

    \033[1;32m# Run with 1 horizontal and 111 vertical columns over 300s with 30s timesteps with single precision \033[0m
    > {0} 1 111 300 30 /home/jgfouca/kokkos-install/install -c ' -DDOUBLE_PRECISION=FALSE'
    # Note the space before the dash
""".format(os.path.basename(args[0])),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("ni", type=int, help="Num horizontal columns. If doing a scaling experiment, this is the starting value.")

    parser.add_argument("nk", type=int, help="Num vertical columns. If doing a scaling experiment, this is the starting value.")

    parser.add_argument("dt", type=int, help="Time step length(s). If doing a scaling experiment, this is the starting value.")

    parser.add_argument("ts", type=int, help="Number of timesteps. If doing a scaling experiment, this is the starting value.")

    parser.add_argument("kokkos", help="Kokkos location")

    parser.add_argument("--cxx", default=os.getenv("CXX"), help="c++ compiler")

    parser.add_argument("-n", "--num-runs", type=int, default=1, help="Number of times to repeat run")

    parser.add_argument("-t", "--test", action="append", choices=("fortran", "cpp", "kokkos", "pack"),
                        help="Select which tests to run, default is all. First one will be used as reference point")

    parser.add_argument("-c", "--cmake-options", default="",
                        help="Extra options to pass to cmake")

    parser.add_argument("-u", "--use-existing", action="store_true",
                        help="Use existing build directory (assumes pwd is build dir)")

    parser.add_argument("-s", "--scaling",
                        help="Do a scaling experiment. Format is VARNAME:SCALE_FACTOR:MAX")

    parser.add_argument("-p", "--plot-friendly", action="store_true",
                        help="Project plot-friendly output")

    parser.add_argument("-T", "--force-threads", type=int, help="Override the machine default for threads.")

    args = parser.parse_args(args[1:])

    if not args.test:
        args.test = ["fortran", "cpp", "kokkos", "pack"]

    args.cmake_options += " -DCMAKE_BUILD_TYPE=Release -DKokkos_DIR={}".format(args.kokkos)
    if args.cxx:
        args.cmake_options += " -DCMAKE_CXX_COMPILER={}".format(args.cxx)

    expect(not args.plot_friendly or args.scaling, "Doesn't make sense to have plot friendly output without a scaling experiment")

    if args.scaling is None:
        scaling_exp = ScalingExp("ni:2.0:{}".format(args.ni))
    else:
        scaling_exp = ScalingExp(args.scaling)
        expect(not (scaling_exp.varname == "threads" and args.force_threads is None),
               "Need to set --force-threads if doing a threading scaling experiment")

    return args.ni, args.nk, args.dt, args.ts, args.force_threads, args.num_runs, args.test, args.cmake_options, args.use_existing, scaling_exp, args.plot_friendly

###############################################################################
def build_p3(cmake_options):
###############################################################################
    with open("build.perf.log", "w") as fd:
        cmake_cmd = "cmake {} ..".format(cmake_options)
        make_cmd  = "make -j8 VERBOSE=1"
        fd.write(cmake_cmd + "\n")
        fd.write(run_cmd_no_fail(cmake_cmd, combine_output=True) + "\n\n")
        fd.write(make_cmd + "\n")
        fd.write(run_cmd_no_fail(make_cmd, combine_output=True).encode('utf-8') + "\n")

###############################################################################
def get_time(output):
###############################################################################
    r"""
    >>> output = 'Foo\nTime = 0.047 seconds.\nbar'
    >>> get_time(output)
    0.047
    >>> output = 'Foo\nTime = 1.732e+01 seconds.\nbar'
    >>> get_time(output)
    17.32
    """
    regex = re.compile(r'Time\s*=\s*([^\s]+)\s*seconds')
    the_time = None
    for line in output.splitlines():
        m = regex.match(line)
        if m:
            expect(the_time is None, "Multiple matches!")
            the_time = float(m.groups()[0])

    return the_time

###############################################################################
def get_threads(output):
###############################################################################
    r"""
    >>> output = 'Foo\nARCH: dp 1 avx  FPE 0 nthread 48\nTime = 0.047 seconds.\nbar'
    >>> get_threads(output)
    48
    """
    for line in output.splitlines():
        if "nthread" in line:
            items = line.split()
            threads = int(items[items.index("nthread") + 1])
            return threads

    expect(False, "Failed to find threads in:\n\n{}".format(output))

###############################################################################
def run_p3(exename, ni, nk, dt, ts, force_threads, num_runs):
###############################################################################
    machine_specific_init(force_threads)
    test_specific_init(exename, force_threads)
    prefix = "" if "NUMA_PREFIX" not in os.environ else "{} ".format(os.environ["NUMA_PREFIX"])
    cmd = "{}{} {} {} {} {} 1".format(prefix, exename, ni, nk, dt, ts)
    results = []
    with open("{}.perf.log".format(exename), "w") as fd:
        fd.write(cmd + "\n\n")
        fd.write("ENV: \n{}\n\n".format(run_cmd_no_fail("env")))
        for _ in range(num_runs):
            output = run_cmd_no_fail(cmd, from_dir="p3")
            fd.write(output + "\n\n")
            results.append(get_time(output))

        threads = get_threads(output)

    return median(results), threads

###############################################################################
def run_fortran(ni, nk, dt, ts, force_threads, num_runs):
###############################################################################
    return run_p3("micro_sed", ni, nk, dt, ts, force_threads, num_runs)

###############################################################################
def run_cpp(ni, nk, dt, ts, force_threads, num_runs):
###############################################################################
    return run_p3("micro_sed_vanilla", ni, nk, dt, ts, force_threads, num_runs)

###############################################################################
def run_kokkos(ni, nk, dt, ts, force_threads, num_runs):
###############################################################################
    return run_p3("micro_sed_vanilla_kokkos", ni, nk, dt, ts, force_threads, num_runs)

###############################################################################
def run_pack(ni, nk, dt, ts, force_threads, num_runs):
###############################################################################
    return run_p3("micro_sed_pack_kokkos", ni, nk, dt, ts, force_threads, num_runs)

###############################################################################
def user_explain(test, med_time, reference, ni):
###############################################################################
    msg = "{} ran in {} seconds".format(test, med_time)
    if reference:
        speedup = (1.0 - (med_time / reference)) * 100
        msg += ", speedup={:.2f}%".format(speedup)

    msg +=", {:.2f} cols/sec".format(ni / med_time)

    print msg

###############################################################################
def perf_analysis(ni, nk, dt, ts, force_threads, num_runs, tests, cmake_options, use_existing, scaling_exp, plot_friendly):
###############################################################################
    if use_existing:
        expect(os.path.isdir("p3") and os.path.exists("CMakeCache.txt"),
               "{} doesn't look like a build directory".format(os.getcwd()))

    else:
        expect(os.path.basename(os.getcwd()) == "micro-apps", "Please run from micro-apps directory")

        tmpdir = tempfile.mkdtemp(prefix="build", dir=os.getcwd())
        os.chdir(tmpdir)

        if not plot_friendly:
            print "BUILDING"

        build_p3(cmake_options)

    results = {}
    while (scaling_exp.should_continue(ni, nk, dt, ts, force_threads)):
        if not plot_friendly:
            print
            print "RUNNING NI", ni, "NK", nk, "DT", dt, "TS", ts, "THREADS {}".format(force_threads) if force_threads else ""

        reference = None
        for test in tests:
            func_name = "run_{}".format(test)
            expect(func_name in globals(), "Unknown test '{}'".format(test))
            med_time, threads = globals()[func_name](ni, nk, dt, ts, force_threads, num_runs)

            if plot_friendly:
                results.setdefault(test, []).append((ni, nk, dt, ts, threads, med_time))
            else:
                user_explain(test, med_time, reference, ni)
            reference = med_time if reference is None else reference

        ni, nk, dt, ts, force_threads = scaling_exp.update_values(ni, nk, dt, ts, force_threads)

    if plot_friendly:
        scaling_exp.plot(results, ni, nk, dt, ts, force_threads)

    return True

###############################################################################
def test_specific_init(test, force_threads):
###############################################################################
    host = socket.gethostname()

    if "blake" in host and test == "micro_sed":
        os.environ["OMP_NUM_THREADS"] = "48"

    if force_threads:
        os.environ["OMP_NUM_THREADS"] = str(force_threads)

###############################################################################
def machine_specific_init(force_threads):
###############################################################################
    host = socket.gethostname()

    if "bowman" in host:
        os.environ["KMP_AFFINITY"] = "balanced,granularity=fine"
        os.environ["OMP_NUM_THREADS"] = "272"
        os.environ["NUMA_PREFIX"] = "numactl -i 1"
    elif "blake" in host:
        os.environ["KMP_AFFINITY"] = "balanced,granularity=fine"
        os.environ["OMP_NUM_THREADS"] = "96"

    if force_threads:
        os.environ["OMP_NUM_THREADS"] = str(force_threads)

###############################################################################
def _main_func(description):
###############################################################################
    ni, nk, dt, ts, force_threads, num_runs, tests, cmake_options, use_existing, scaling_exp, plot_friendly = \
        parse_command_line(sys.argv, description)

    machine_specific_init(force_threads)

    success = perf_analysis(ni, nk, dt, ts, force_threads, num_runs, tests, cmake_options, use_existing, scaling_exp, plot_friendly)

    sys.exit(0 if success else 1)

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
