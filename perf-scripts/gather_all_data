#!/usr/bin/env python3

"""
Gather all performance data on all platforms of interest and store
them in a git branch.

It is expected that you are able to do a passwordless ssh to all
machines and that the given repo on the target machines are clean.
Since testbeds do not allow login via ssh key, you'll need to use kinit.
Waterman is on the SRN, so you'll need to start from a SRN machine. I've
had good luck using face.sandia.gov as my launch machine.

It is expected that your current repo is clean and that your current commit
is the one you want to test.
"""

from utils import run_cmd_no_fail, expect, check_minimum_python_version, get_current_commit
check_minimum_python_version(3, 5)

import argparse, sys, os
import concurrent.futures as threading3

# MACHINE -> (env_setup, repo-loc, kokkos-install-loc, compiler, batch submit prefix)
MACHINE_METADATA = {
    "melvin"   : (["module load sems-gcc/7.3.0 sems-openmpi/1.10.1 sems-gcc/7.3.0 sems-git/2.10.1 sems-cmake/3.10.3 sems-python/3.5.2"], "$(which mpicxx)", ""),
    "bowman"   : (["module load openmpi/1.10.6/intel/17.2.174 git/2.8.2 cmake/3.12.3", "export PATH=/ascldap/users/jgfouca/packages/Python-3.6.8-bowman/bin:$PATH"], "$(which mpicxx)", "srun"),
    "blake"    : (["module load openmpi/2.1.5/intel/19.1.144 git/2.9.4 cmake/3.12.3", "export PATH=/ascldap/users/jgfouca/packages/Python-3.6.8-blake/bin:$PATH"],  "$(which mpicxx)", "srun"),
    "waterman" : (["module load devpack/latest/openmpi/2.1.2/gcc/7.2.0/cuda/9.2.88 git/2.10.1", "module switch cmake/3.12.3", "export PATH=/ascldap/users/jgfouca/packages/Python-3.6.8-waterman/bin:$PATH"],
                  "$(which mpicxx)", "bsub -I -q rhel7W"),
    "white"    : (["module load devpack/20181011/openmpi/2.1.2/gcc/7.2.0/cuda/9.2.88 git/2.10.1 cmake/3.12.3", "export PATH=/ascldap/users/jgfouca/packages/Python-3.6.8-white/bin:$PATH"], "$(which mpicxx)", "bsub -I -q rhel7G"),
}

###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <PERF-ANALYSIS-ARGS> [--verbose]
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Gather data \033[0m
    > {0} '64 128 300 30 10 $kokkos_install --cxx=$compiler -s "ni:2.0:16384" -n 10'
    # NOTE: leave the variables in the args unresolved so the script can resolve them

    \033[1;32m# Gather data for specific tests and specific machines \033[0m
    > {0} '64 128 300 30 10 $kokkos_install --cxx=$compiler -t ref -t final -s "ni:2.0:16384" -n 10' -m waterman -m bowman

    \033[1;32m# Do correctness testing instead of performance testing \033[0m
    > {0} -t

    \033[1;32m# Do correctness testing locally for SCREAM (expects ./scream and ./scream-docs) \033[0m
    > {0} -l -s -m $machine
""".format(os.path.basename(args[0])),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("perf_analysis_args", nargs="?", help="Args to pass to perf_analysis")

    default_commit = get_current_commit(short=True)
    parser.add_argument("-c", "--commit", default=default_commit, help="Commit to test")

    parser.add_argument("-m", "--machine", action="append", choices=MACHINE_METADATA.keys(),
                        help="Select which machines to run on, default is all")

    parser.add_argument("-l", "--local", action="store_true",
                        help="Run tests on local machine")

    parser.add_argument("-t", "--test-all", action="store_true", help="Run test-all instead of performance gathering")

    parser.add_argument("-s", "--scream", action="store_true", help="Test scream instead of scream-docs. Implies --test-all")

    parser.add_argument("-k", "--kokkos", help="Use to select specific kokkos installation.")

    parser.add_argument("--submit", action="store_true", help="Submit results to dashboard (scream-only).")

    args = parser.parse_args(args[1:])

    expect(not (args.local and len(args.machine) > 1),
           "Cannot run on multiple machines if local")

    if not args.machine:
        args.machine = MACHINE_METADATA.keys()

    if args.scream:
        args.test_all = True

    if args.submit:
        expect(args.scream, "Dashboard sumbission is only supported for scream")

    if not args.commit:
        expect(args.local, "Could not determine commit")
        args.commit = get_current_commit(short=True, repo="./scream") if args.scream else get_current_commit(short=True, repo="./scream-docs")

    return args.perf_analysis_args, args.commit, args.machine, args.test_all, args.scream, args.local, args.kokkos, args.submit

###############################################################################
def formulate_command(machine, perf_analysis_args, commit, test_all, scream, local, kokkos, submit):
###############################################################################
    env_setup, compiler, batch = MACHINE_METADATA[machine]

    if local:
        scream_docs_repo = os.path.abspath("./scream-docs/micro-apps")
        repo             = os.path.abspath("./scream/components/scream") if scream else scream_docs_repo
    else:
        scream_docs_repo = "~/scream-docs-perf-{}/micro-apps".format(machine)
        repo             = "~/scream-perf-{}/components/scream".format(machine) if scream else scream_docs_repo

    test_all_script = "../perf-scripts/test-all-scream" if scream else "test-all"
    submit_args = "-s" if submit else ""

    kokkos_arg = "-k {}".format(kokkos) if kokkos else ""
    kokkos_loc = kokkos if kokkos else os.path.join(os.path.dirname(os.path.dirname(repo)), "externals", "kokkos")

    local_cmd = "{}/{} {} {} {} -m {}".format(scream_docs_repo, test_all_script, compiler, kokkos_arg, submit_args, machine) if test_all else "../perf-scripts/perf_analysis {} -p".format(perf_analysis_args)
    local_cmd = local_cmd.replace("$compiler", compiler)

    setup = "cd {} && git fetch && git reset --hard origin/master && ".format(scream_docs_repo) if (scream and not local) else ""
    extra_env = ""
    if machine in ["waterman", "white"]:
        extra_env = "OMPI_CXX={}/bin/nvcc_wrapper ".format(kokkos_loc)
    else:
        extra_env = "OMP_PROC_BIND=FALSE "

    repo_setup = "true" if (local or not commit) else "git fetch && git checkout {} && git submodule update --init".format(commit)

    cmd = "{}cd {} && {} && {} && {}{} {}".format(setup, repo, " && ".join(env_setup), repo_setup, extra_env, batch, local_cmd)

    return cmd

###############################################################################
def run_on_machine(machine, perf_analysis_args, commit, test_all, scream, local, kokkos, submit):
###############################################################################
    cmd = formulate_command(machine, perf_analysis_args, commit, test_all, scream, local, kokkos, submit)
    print("Starting {} analysis on {} with cmd: {}".format("test-all" if test_all else "performance", machine, cmd))

    if local:
        run_cmd_no_fail(cmd, arg_stdout=None, arg_stderr=None, verbose=True, exc_type=RuntimeError)
    else:
        output = run_cmd_no_fail("ssh -o StrictHostKeyChecking=no {} '{}'".format(machine, cmd), exc_type=RuntimeError)
        with open(os.path.join("test-all-results" if test_all else "perf-results", commit, machine), "w") as fd:
            fd.write(output)

    print ("Completed {} analysis on {}".format("test-all" if test_all else "performance", machine))

###############################################################################
def gather_all_data(perf_analysis_args, commit, machines, test_all, scream, local, kokkos, submit):
###############################################################################
    if not local:
        os.makedirs(os.path.join("test-all-results" if test_all else "perf-results", commit))

    success = True

    with threading3.ThreadPoolExecutor(max_workers=len(machines)) as executor:
        future_to_machine = {executor.submit(run_on_machine, machine, perf_analysis_args, commit, test_all, scream, local, kokkos, submit): machine for machine in machines}
        for future in threading3.as_completed(future_to_machine):
            machine = future_to_machine[future]
            try:
                future.result()
            except RuntimeError:
                print('{} failed'.format(machine))
                success = False

    return success

###############################################################################
def _main_func(description):
###############################################################################
    perf_analysis_args, commit, machines, test_all, scream, local, kokkos, submit = parse_command_line(sys.argv, description)

    success = gather_all_data(perf_analysis_args, commit, machines, test_all, scream, local, kokkos, submit)

    sys.exit(0 if success else 1)

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
